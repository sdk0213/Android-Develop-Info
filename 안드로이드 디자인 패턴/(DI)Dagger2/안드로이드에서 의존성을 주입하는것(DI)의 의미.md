# 안드로이드에서 의존성을 주입하는것의 의미
---
### 태초에 main()이 있었다.
* 태초에 프로그램의 시작점인 main이 있다. 프로그래밍을 처음할때 배우는 대부분의 언어가 main()에서 시작한다. 우리는 프로그래밍의 시작점인 main에서부터 앞으로 어떻게 컴퓨터가 일하도록 할것인지 명령을 내릴수있다.
그러한 명령체계는 언어에 따라 다르다. 사실 프로그래밍상 main은 프로그래밍의 시작점은 아니다. 아마도 진짜 프로그램의 시작점은 우리가 사용하는 언어가 우리가 프로그래밍한것을 더 하등한 언어로 바꾸어서 cpu에게 전달하면 cpu가 판단하여 시작될것이다.
여하튼 그 시작점이 어디든 간에 우리가 프로그래밍하는 언어에는 시작점이 있다. 그것이 main이든 뭐든간에 말이다.
---
### 안드로이드는 어떨까?
* 안드로이드에도 시작점이 있다. 정확히 말하기는 애매하지만 manifest에 application으로 선언된 부분안에 activity로 시작되는 부분의 filter로 android.intent.action.MAIN 선언하면 그것이 안드로이드 프로그래밍의 시작점이다.
이것이 우리가 알고있는 main이자 시작점이다. 물론 정확히 따지자면 이것이 시작점은 아니다. 안드로이드 시스템에서 우리가 코딩으로 컨트룰할수 있는 영역의 시작점이다.
---
### 여하튼 간에 이 시작점으로부터 의존성이 시작된다.
* 이제 main에서부터 시작해서 우리는 클래스를 만들고 코딩을 시작한다. 내가 만들고 싶은것을 클래스로 만들거나 이미 만들어진 외부 라이브러리를 사용하거나 여하튼간에 우리가 Main에서부터 여러가지 명령으로 방을 꾸미는것이다.
그렇다면 이제 슬슬 어떤 클래스는 다른 클래스를 필요로 할것이다. 그렇게 서로 다른 클래스가 서로를 의존하기 시작한다.
---
### A라는 클래스에 C라는 클래스가 필요할때...
* main에서부터 시작된 코딩이 A,B,C~~~ Z 라는 클래스까지 만들어버렸다. 근데 A라는 클래스에서 C라는 클래스가 필요하다. 그래서 우리는 C라는 클래스를 new로 생성한다. 근데 이럴때 단순히 A라는 클래스에서 필요할때마다
new 로 새롭게 생성하는것이 좋은것일까? 아니라면 이미 생성된 C라는 클래스를 가져오는것이 좋을까? 음.. 케이스마다 달라서 정확한 기준을 말할수는 없을것이다. 하지만 new 를 사용해서 새로운것을 만드는것은 꽤나 위험하다.
왜그럴까? C 클래스가 변경이 되었다고 치자. 그러면 A라는 클래스에서 C라는 클래스도 어느정도 변경이 필요할것이다. 많이 바뀔수록 더 많은 변경이 필요할것이다. 이때부터 슬슬 문제가 발생한다. C라는 클래스는 사실 A뿐만 아니라
F, H, Z 클래스에서도 사용하고 있었다. A, F, H, Z 클래스가 직접 C라는 클래스를 만들어 사용하고 있으니 C라는 클래스가 변경될때 따라오는 책임을 A, F, H, Z 클래스도 함께 지어야 되는것이다. 이를 해결하기 위해서는 어떻게 해야할까?
---
### 밖에서 클래스를 넣어주자
* 태초에 main이 있었다고 얘기했다. 이 Main에서부터 코딩을 하면서 의존성이 시작된다고 할수있다. main에서 A, F, H, Z 클래스를 만들었다. 이 4개의 클래스는 또 C라는 클래스를 직접 만들어서 쓰고 있다.
이를 main에서 A, F, H, Z 클래스를 생성할때 생성자로 넣어주기로 했다. 이것이 바로 DI 이다. 밖에서 안으로 즉, main에서 C라는 클래스를 만들어서 A, F, H, Z 클래스로 넣어주는것이다. A, F, H, Z클래스는 생성자로 C라는 클래스를 받는것이다.
---
### main에서 c를만들어서 집어넣어주면 뭐가 달라지나?
* 달라지는 점이 있다. 앞으로 A, F, H, Z는 C 클래스가 변경될때마다 모든 책임을 가질필요가없다. 왜냐하면 나는 그냥 main에서 C클래스를 던져주어서 받아서 쓰기만 하면되기 때문이다. 모든책임은 이제 main으로 넘어갔다.
생각해보자. C라는 클래스를 생성하는놈이 네곳에서 한곳으로 줄었다. 이에 변경이 용이해졌다. 이 말은 의존성은 그대로 두면서 결합도는 떨어트린것이다. 이렇게 밖에서 안으로 의존이 필요한것들을 집어넣어주는것을 DI라고 한다.
---
### 그럼 그렇게 넣어주면 되는것이지 왜 라이브러리를 사용해서 주입할까?
* 생성자를 통해 주입을 하는것이 쉬우면 좋겠지만 생각보다 의존성을 잘 생성해서 만들고 관리하는것은 복잡하다. 예를들어서 H라는 클래스에는 A, B 클래스가 필요고 A는 C를 B는 D라는 클래스는 필요하다고 가정하면
이를 순서에 맞게 주입을 시켜줘야 할뿐만 아니라 그 과정도 복잡할뿐더러 개발자가 이 모든것을 생각하기에는 설계상에서 놓치는 부분이 있을수가 있다. 또한 H라는 클래스를 사용할때마다 A와 C, B와 D라는 클래스를 매번
의존성 주입을 해주어야 하기때문에 한번 사용할때마다 보일러 플레이트(상용구 코드)가 생성된다. 내가 만드는 프로그램이 작으면 상관이없는데 점점 기능이 추가될때마다 클래스량은 늘어나고 서로 의존성은 심하될텐데 의존성을
밖에서 주입해야하는 DI 를 실천하기 위해서 개발자가 해야할일은 끝도없이 증가한다. 그리고 이 모든것의 시작을 태초의 시작점인 main()에서부터 다 해줘야 한다.
---
### 그래서 이에 대한 해결책으로 DI 라이브러리같은것이 존재하는것이다.
* 내가 알기로는 안드로이드 뿐만아니라 웹도 그렇고 다양한 DI 라이브러리 존재하는것으로 알고있다. 안드로이드에는 Dagger가 있다. 안드로이드에서 사용하는 Dagger는 main()이라고 불리는 곳부터 의존성을 주입해준다.
보통은 Application() 영역을 프로그래밍의 시작점인 main()으로 잡고 Activity 그리고 Fragment 순으로 의존성을 주입해준다. 근데 이게 또 복잡하다. 안드로이드는 생명주기도 있어서 클래스가 있었다가 생명주기가 꺼지면 
없어져버린다. 그래서 안드로이드 개발자면 반드시 지켜야하는 몇가지 규칙들도 있다. 근데 Dagger가 안드로이드를 위한 DI 라이브러리인 만큼 이를 잘 극복하며 DI를 시켜준다.
---
### Dagger를 사용할때의 코드 변화는?
* 우선 일반적인 생성자 주입을 해보면 다음과 같을것이다. 아주간단하게 테스트를하기위해 대충 코드를 작성해보자. 아이디를 서버로 전송하고 이름을 받아와서 해당 이름으로 사람 객체를 생성하는 코드이다.
이해를 돕기위해 아주 대충 작성한 코드이므로 너무 코드 자체에 신경쓰지 말자
##### 적용 전
* Person
  ```java
  class Person{
   
      private getNameFromNetWorkDB gnfdb;
      
      Person(String gnfdb){
        this.gnfdb = gnfdb;
      }
      
      getName(){
          gnfdb.getName();
      }
  }
* 네트워크로부터 이름을 가져오는 코드
  class getNameFromNetWorkDB(){

      private id;
      
      getNameFromNetWorkDB(String id){
      
      }
      
      String getName(){
          // 서버통신을 통해 원격으로 Id를 전송하고 그 아이디 주인의 이름을 가져오는 코드가 안에 들어있다고 가정
      }
  }
* Main
  ```java
  //생성자 주입
  main()
      getNameFromNetWorkDB gnfdb = new getNameFromNetWorkDB("sdk0213");
      Person person = new Person(gnfdb)
  }
* Person은 getNameFromNetWorkDB에 의존성한다고 볼수있다. 
##### 적용 후
* getNameFromNetWorkDB 을 모듈에 넣기
  ```java
  @Module
  class TestModule {

      @Provides
      getNameFromNetWorkDB provideGetNameFromNetWorkDB(){
          return getNameFromNetWorkDB("sdk0213");
      }
  }
* Compoennt에 Person 넣기
  ```java
  @Component(modules = [TestModule::class])
  interface TestComponent {
      Person InjectedPerson();
  }
* Person
  ```java
  class Person{
   
      private getNameFromNetWorkDB gnfdb;
      
      @Inject
      Person(String gnfdb){
        this.gnfdb = gnfdb;
      }
      
      getName(){
          gnfdb.getName();
      }
  }
* Main
  ```java
  //생성자 주입
  main()
      // getNameFromNetWorkDB gnfdb = new getNameFromNetWorkDB("sdk0213");
      // Person person = new Person(gnfdb)
      // 위의 코드가 아래와 같이 변경 되었다. 내가 객체 생성에 필요한 의존성을 직접 삽입할필요도 없다.
      Person person = DaggerTestComponent.create().InjectedPerson();
  }
### 적용전과 적용후의 코드를 보자.
* Main에서 내가 객체를 생성하고 넣어주는 코드가 없어졌다. 이 모든것들은 Dagger가 알아서 찾아서 삽입해준다. DaggerTestComponent는 규칙에 따라서 Dagger가 생성하는 코드인데 코드를 들여다보면은 결국은
모듈이랑 @Inject한것을 이어주는 코드이다. 대신 의존성을 넣어주는것이다. 어떤 원리로 어떤식으로 처리되는지는 나도 정확히는 파악이 불가능하지만 코드를 따라가다보면은 결국은 저 둘을 이어주기 위한 코드일뿐이라는것을
파악할수 있다. 그리고 이런 Dagger를 사용하기위해서는 몇가지 규칙이 있다. 그거는 Dagger를 공부해야한다. Dagger를 사용함으로써 이제 개발자는 의존성 떄문에 머리 복잡할일이 사라졌고 로직에 더 집중할수있게되는것이다. 이것이 바로 Dagger라이브러리를 사용하는 진짜 이유이다. 나도 지금 Dagger를 공부한지 2주밖에 안되고 사실 아직까지도 이해가 안가는부분이 많다. 하지만 Dagger를 공부함으로써 얻는 이익이 더 많은것을 느낀다.
