코틀린 함수
===
> 3.2.1 함수를 데이터로 이해하기
* **코틀린**에서는 함수가 함수를 반환하고 인자로 넘길수있고 리스트나 맵 같은 데이터 구조에 저장할수 있고 심지어는 데이터베이스에 함수를 저장할수 있다.
* **물론** fun으로 정의한 함수는 이런방식으로 조작이 불가능하지만 이런 메서드를 진짜 함수로 변화할수 있게 **코틀린이 모든 메커니즘을 제공**한다.

> 3.2.2 데이터를 함수로 이해하기
* 상수함수
  * 인자에 따라 반환하는 값이 달라지지 않는 특별한유형의 함수

> 3.2.3 객체 생성자를 함수로 사용하기
* **객체 생성자**는 사실 **함수**다
* 그렇다면 순수함수이여야 하고 다음과 같은 코드는 같은 결과를 돌려줘어 한다.
  * .kt
    ```kotlin
    val elvis = Person("Elvis")
    val theKing = Person("Elvis")
  
    println(elvis == theKing) // 동등성 검사

    // 여기서 결과가 true로 나오면 순수함수이다
    // 데이터 클래스라면 true 아니라면 equals에 따라 달라진다

> 3.2.4 코틀린 fun 함수 사용하기
* 순수함수(pure function)의 조건
  * 함수 외부의 어떤 것도 변이시켜서는 안 된다. 내부에서 상태를 변이시키더라도 그 상태를 **외부에서 관찰할 수 없어야** 한다.
  * **인자를 변이시켜서는 안** 된다.
  * **예외나 오류를 던져서는 안** 된다.
  * **항상 값**을 **반환**해야 한다.
  * **인자**가 **같**으면 **항상** **같은 결과**를 내놓아야 한다.
* .kt
  ```kotlin
  // 위의 순수함수의 조건에 만족하는 함수가 포함된 함수는 다음과 같이 주석을 참고
  class FunFunctions {
    
    var percent1 = 5
    private var percent2 = 9
    val percent3 = 13
    
    fun add(a: Int, b: Int): Int = a + b // --> 순수함수
    
    fun mult(a: Int, b: Int?): Int = 5 // --> 순수함수
    
    fun div(a: Int, b: Int): Int = a / b // 만약에 b에 0이 들어가면 '계산불가'로 Exception이 발생하여 순수함수가 아니다.
    
    fun div(a: Double, b: Double): Double = a / b // --> 순수함수(0.0으로 나누면 infinity, -infinity가 출력되고 이는 double의 인스턴스이기 때문이다.)
    
    fun applyTax1(a: Int): Int = a / 100 * (100 + percent1) // 우선 percent1가 변경되지 않아서 순수함수이지만 percent2가 항상 바뀔수 있기 때문에 안전하지 않다.
    
    fun applyTax2(a: Int): Int = a / 100 * (100 + percent2) // 우선 percent2가 변경되지 않아서 순수함수이지만 percent2가 항상 바뀔수 있기 때문에 안전하지 않다.
    
    fun applyTax3(a: Int): Int = a / 100 * (100 + percent3) // --> 순수함수 (percent3가 상수이기 때문이다.)
    
    fun append1(i: Int, list: MutableList<Int>): List<Int> { // 반환전에 list를 변이시키고 함수밖에서 관찰까지 가능하니 순수함수가 아니다.
      list.add(i)
      return list
    }
    
    fun append2(i: Int, list: List<Int>) = list + i // --> 순수함수 (list + i 는 list + i라는 새로운(불변) 리스트를 만들어내는것이라서 순수함수다.)
    
    
> 3.2.5 객체 표기법과 함수 표기법 비교
* 자신이 들어 있는 클래스 인스턴스에 접근하지 않는 함수는 해당 클래스 밖, 동반객체, 패키지수준 으로 빼내도 안전하다.
* 클래스 인스턴스를 **명시적으로 파라미터**로 받게 만들면 클래스 인스턴스의 프로퍼티에 접근하는 함수를 **동반객체나 패키지 수준**에 넣을 수 있다.
* .kt
  ```kotlin
  class Payment(val creditCard: CreditCard, val amount: Int) {
    fun combine(payment: Payment): Payment =
      if (creditCard == payment.creditCard)
        Payment(creditCard, amount + payment.amount)
      else
        throw IllegalStateException("Cards don't match.")
    companion object {
      fun groupByCard(payments: List<Payment>): List<Payment> =
        payments.groupBy { it. creditcard }
                .values
                .mape { it.reduce(Payment::combine) }
    }
  }
  // combine 함수는 자신을 둘러싸고 있는 클래스의 인스턴스를 암시적 파라미터로 받는다. 만약 이 파라미터를 명시하게 만들면 패키지수준이나 동반 객체안에 위치시킬 수 있다. 예를들어서 다음과 같다.
  
  fun combine(payment1: Payment, payment2: Payment): Payment = // 이제 굳이 creditCard가 필요하지 않으니까 클래스를 벗어나 밖에서도 사용가능하다.
    if (payment1.creditCard == payment2.creditCard)
      Payment(payment1.creditCard, payment1.amount + payment2.amount)
    else
      throw IllegalStateException("Cards don't match.")
  // 위 방식을 클래스 내부에서 사용할경우 다음과 같이 this를 사용해야 할수도 있다.
  val newPayment = combine(this, otherPayment)
* 만약에 위의 함수를 **합성** 한다면 **큰 차이**가 생긴다. 그리고 이럴때 **객체 표기법**이 도움이 된다.
  * .kt
    ```kotlin
    fun combine(payment: Payment): Payment =
      if (creditCard == payment.creditCard)
        Payment(creditCard, amount + payment.amount)
      else
        throw IllegalStateException("Cards don't match.")
    
     // 기존
     import ...Payemnt.Companion.combine
     
     val newPayment = combine(combine(payemnt1, payment2), payment3)
     
     // 객체 표기법
     val newPayment = payment1.combine(payment2).combine(payment3)
