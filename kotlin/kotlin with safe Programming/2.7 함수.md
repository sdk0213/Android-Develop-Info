함수
===
* 코틀린 **함수(function)** ≒ 자바 **메서드(method)**

함수 선언
---
* .kt
  ```kotlin
  fun add(a: Int, b: Int): Int {
    return a+b
  }
  
  // 위 함수는 아래처럼 변형이 가능하며 이를 식 구문(expression syntax)이라고 부른다.
  fun add(a: Int, b: Int) = a + b // 식 구문 사용시 반환타입 생략가능
  
  // 만약에 헷갈려서 다음과 같이 잘못쓸경우 잘못된 코드는 아니라서 컴파일되지만 반환 타입이 우리의 예상과 다르고 오류를 컴파일러가 알려줄수 없게 된다.
  fun add(a: Int, b: Int) {
    a + b
  }

로컬 함수
---
* 클로저(closure)
  .kt
  ```kotlin
  fun sumOfPrimes(limit: Int): Long {
    val seq: Sequence<Long> = sequenceOf(2L) + generateSequence(3L, {
      it + 2
    }).takewhile{
      it < limit
    }
    
    fun isPrime(n: Long): Boolean = seq.takeWhile {
      it * it <= n
    }. all {
      n % it != 0L
    }
    
    return seq.filter(::isPrime).sum()
  }
  
  // non-closure
  fun sumeOfPrimes(limit: Int): Long {
    val seq: Sequence<Long> = sequenceOf(2L) + generateSequence(3L, {
      it + 2
    }).takeWhile{
      it < limit
    }
    
    return seq.filter {
      x -> isPrime(x.seq)
    }.sum()
  }
  
  fun isPrime(n: Long, seq: Sequence<Long>): Boolean = seq.takeWhile {
    it + it <= n
  }.all {
    n % it != 0L
  }

*  클로저(closure)란 **자신이 가두어 닫은 변수**를 함수 **인자**로 받는 것
*  isPrime 함수를 호출하려고 람다를 정의하는대신 함수참조를 사용할수 있다.
*  밖에서 사용할 가능성이 적으면 로컬함수로 만들어 클로저(closure)와 함수 참조를 사용하게 만드는 편이 낫다

함수 오버라이드하기
---
*  .java
   '''java
   @Override // use annotation 
*  .kt
   '''kotlin
   override fun sun(a: Int, b: Int)
