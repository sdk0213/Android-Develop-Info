함수
===
* 코틀린 **함수(function)** ≒ 자바 **메서드(method)**

함수 선언
---
* .kt
  ```kotlin
  fun add(a: Int, b: Int): Int {
    return a+b
  }
  
  // 위 함수는 아래처럼 변형이 가능하며 이를 식 구문(expression syntax)이라고 부른다.
  fun add(a: Int, b: Int) = a + b // 식 구문 사용시 반환타입 생략가능
  
  // 만약에 헷갈려서 다음과 같이 잘못쓸경우 잘못된 코드는 아니라서 컴파일되지만 반환 타입이 우리의 예상과 다르고 오류를 컴파일러가 알려줄수 없게 된다.
  fun add(a: Int, b: Int) {
    a + b
  }

로컬 함수
---
* 클로저(closure)
  .kt
  ```kotlin
  fun sumOfPrimes(limit: Int): Long {
    val seq: Sequence<Long> = sequenceOf(2L) + generateSequence(3L, {
      it + 2
    }).takewhile{
      it < limit
    }
    
    fun isPrime(n: Long): Boolean = seq.takeWhile {
      it * it <= n
    }. all {
      n % it != 0L
    }
    
    return seq.filter(::isPrime).sum()
  }
  
  // non-closure
  fun sumeOfPrimes(limit: Int): Long {
    val seq: Sequence<Long> = sequenceOf(2L) + generateSequence(3L, {
      it + 2
    }).takeWhile{
      it < limit
    }
    
    return seq.filter {
      x -> isPrime(x.seq)
    }.sum()
  }
  
  fun isPrime(n: Long, seq: Sequence<Long>): Boolean = seq.takeWhile {
    it + it <= n
  }.all {
    n % it != 0L
  }

*  클로저(closure)란 **자신이 가두어 닫은 변수**를 함수 **인자**로 받는 것
*  isPrime 함수를 호출하려고 람다를 정의하는대신 함수참조를 사용할수 있다.
*  밖에서 사용할 가능성이 적으면 로컬함수로 만들어 클로저(closure)와 함수 참조를 사용하게 만드는 편이 낫다

함수 오버라이드하기
---
* .java
  ```java
  @Override // use annotation 
  public boolean onCreateOptionMenu(Menu menu) { ... }
* .kt
  ```kotlin
  override fun onCreateOptionsMenu(menu: Menu?): Boolean { ... }
* 실수로 함수를 오버라이딩하는 것을 방지할 수 있다.

확장 함수(extension function) 사용하기
---
* **클래스에 정의**된 **인스턴스** 함수인 것**처럼 객체**를 **호출**할 수 있는 **함수**를 말한다
* .kt
  ```kotlin
  fun <T> length(list: List<T>) = list.size
  
  // exam1 - 마치 클래스안에 들어있는 함수처럼 사용한다.
  fun <T> List<T>.length() = this.size // 프로퍼티 구문으로 호출할 수 있는 size 함수와 달리 꼭 () 괄호를 사용해야 한다.

  val ints = listOf(1, 2, 3, 4, 5, 6, 7) // listOf의 반환객체는 List이다.
  val listLength = ints.length()  // 마치 원래 List안에 들어있는 함수마냥 사용
  
  // exam2 - 
  fun List<Int>.product(): Int = this.fold(1) { a, b -> a*b }
  
  val ints = listOf(1, 2, 3, 4, 5, 6, 7)  
  val product = ints.product() // 마치 원래 List안에 들어있는 함수마냥 사용
  
* 자바에서는 이런 확장 함수를 인스턴스 메서드처럼 호출 불가능하다.
* **하지만 코틀린에서는** **가능**하며 정적 메서드로 호출해야 한다.

람다 사용하기
---
* 람다 = 익명함수(anonymous function) = "이름이 없다"
> 사용법
* .kt
  ```kotlin
  // 람다 사용
  fun triple(list: List<Int>): List<Int> = list.map({ a -> a * 3})
  // 유일한 인자면 괄호 생략가능
  fun triple(list: List<Int>): List<Int> = list.map( a -> a * 3)
  // 괄호에 따라서 의미가 달라지기 때문에 주의해야한다.
  // 예를들어서 다음 코드는 컴파일되지 않는다.
  fun List<Int>.product(): Int = this.fold(1) {(a, b) -> a * b}
  
  
  
