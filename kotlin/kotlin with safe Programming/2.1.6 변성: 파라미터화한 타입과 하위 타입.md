변성(variable)
===
* 변성(variable)
  * **파라미터**화한 **타입**이 서로 **어떤** **하위** 타입 **관계**에 있는지 **결정**하는 방식
* 공변성(covarinace)
  * 색깔 'RED'는 'COLOR'의 하위 타입일때 Mathcer< Red >도 Macher< Color >의 하위타입이고 이는 **Matcher< T >** 는 타입 파라미터 **T**에 대해 **공변성**이라고 말한다.
  * Matcher< Color >가 Matcher< Red >의 하위 타입이라면 Matcher< T >는 타입 파라미터 T에 대해 **반공변성**(contravariant)이라고 말한다.
  * 예를들어서 **List < String >**은 **Any**의 **하위** 타입이다.
* **자바**에서는 **와일드카드**를 사용해야한다.
* **코틀린**에서는 **'in', 'out'** 키워드로 변성을 **지정**한다. 아무키워드도 없다면 **무공변성**(invariant)이다.

> 변성이 문제인 이유
* Any는 String의 부모이기 때문에 다음과 같은 코딩이 가능하다.
  * .kt
    ```kotlin 
    val s = "A String"
    val a: Any = s
* 만약에 **공변**이라면 다음과 같은 **문제가 발생**하고 만약에 된다고 한다면 결국은 Int값까지 집어넣을수있게된다.
  * .kt
    ```kotlin
    val ls = mutalbeListOf("A String")
    val la: MmutableList<Any> = ls // <--- 컴파일 오류
    la.add(42) // 컴파일이 된다면 Int값을 집어넣을수 있게 된다.
* 문자열 + Int = Any
  * .kt
    ```kotiln
    val ls = listOf("A String")
    val la = ls + 42 // <-- 코틀린은 'la'의 타입을 'List<Any>'로 추론함
* **자바**에서는 파라미터화한 타입이 파라미터 타입에 대해 **무공변성** 이다. 즉, A 가 B 의 부모 타입이라 하더라도 List<A> 와 List<B> 사이에는 **아무런 부모 자식 타입 관계가 성립하지 않는다.**
 
* 무공변성 타입의 문제 예
  * .kt
    ```kotlin
    fun <T> addAll(list1: MutableList<T>, list2: MutableList<T> {
      for (elem in list2) list1.add(elem)
    }
 
    val ls = mutableListOf("A String")
    val la: MutableList<Any> = mutableListOf()
    addAll(la, ls) // <-- 컴파일 되지 않음

                     
   
   
