defer() 함수
===
* timer()함수와 비슷하지만 **데이터 흐름 생성을 구독자가 subscribe() 함수를 호출할 때 까지 미룰** 수 있다.
* marblediagram
  ![](img/marblediagram_defer.png)
* 원형
  ```java
  @SchedulerSupport(SchedulerSupport.NONE) // 스케쥴러 없음, 말인 즉 메인스레드에서 실행된다.
  public static <T> Observable<T> defer(
    Callable<? extends ObservableSource<? extends T>> Supplier) { }
* Callable객체 이기 때문에 call() 메서드의 호출을 미룰 수 있다.
* 활용
  ```java
  Iterator<String> colors = Arrays.asList("1", "3", "5", "6").iterator();
  
  @Override
  public void marbleDiagram() {
    Callable<Observable<String>> supplier = () -> getObservable();
    Observable<String> source = Observable.defer(supplier);
  
    source.subscribe(val -> Log.i("Subscriber #1:" + val));
    source.subscribe(val -> Log.i("Subscriber #2:" + val));
    CommonUtils.exampleComplete();
  }
  
  // 번호가 적힌 도형을 발행하느 Observable을 생성합니다.
  private Observable<String> getObservable() {
      if (colors.hasNext()) {
          String color = colors.next();
          return Observable.just(
            Shape.getString(color, Shape.BALL):
            Shape.getString(color, Shape.RECTANGLE):
            Shape.getString(color, Shape.PENTAGON):
      }
      
      return Observable.empty();
  }
  
  // result:
  // main | value = Subscriber #1:1
  // main | value = Subscriber #1:1-R
  // main | value = Subscriber #1:1-P
  // main | value = Subscriber #2:3
  // main | value = Subscriber #2:3-R
  // main | value = Subscriber #2:3-P
  
> 만약에 defer()를 사용하지
